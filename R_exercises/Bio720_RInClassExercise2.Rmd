---
title: "Bio720 R In Class Exercise 2"
author: "Ian Dworkin"
date: "October 24, 2016"
---


## for loops and the apply family of functions
This past week for screencasts and exercies, you learned a bit about how to use `for` loops and `apply` family of functions. Now we are going to do some in class practice and extend your understanding of how they work. In case you want some alternative tutorials [here](https://www.datacamp.com/community/tutorials/tutorial-on-loops-in-r#gs.FgFVHlY) is one that goes into more detail.

1. What happens to `x` for each of these functions after you run them?

```{r}
rm(x)
x <- 1

for (i in 1:9) {
    x <- x + 1
    print(x)
}

x

```
**VS**

```{r}
rm(x)

countFun <-function(x)
{
  
  for (i in 1:10) {
    x <- x + 1
    print(x)
}}

countFun(1)
x
```

Why do these behave differently?


These behave differently because in one case we have assigned a value to the variable `x` in the global environment, while in the second example the variable is assigned within the context of the `countFun` function. This is because the assignment happened within the context of the function. The details of how this work can get complicated, and different programming languages handle it differently. For more information you should look up a bit about *lexical scoping* and the idea of *environments* in `R`. What is important though is that unless you specifically ask for a variable to be returned from a function, *What happens in a function, stays in the function* for `R`. There are a few exceptions, but keep this in mind generally. This [tutorial](https://darrenjw.wordpress.com/2011/11/23/lexical-scope-and-function-closures-in-r/) might give you some more ideas.


2. Write a for loop that generates a vector which is the square of all integers from 1 to 10000. Make this all happen within the loop. i.e. We are going to use the `system.time()` function to monitor how long it takes.

*Note: to use system time the for loop all needs to be on one line*

```{r}
# initialize a vector of length 1
rm(x)
x <- NA

#system.time( YOUR FOR LOOP HERE)

system.time( for (i in 1:10000)) {x[i] <- i^2})
```
3. Now do the sama thing but *pre-allocate* the vector `x` to store the 10000 values, *before* running the for loop.

```{r}
# initialize a vector of length 1
rm(x)
x <- rep(NA, 10000)

#system.time( YOUR FOR LOOP HERE)

system.time( for (i in 1:10000) {x[i] <- i^2})
```
Which runs faster? Please explain why?

When we pre-allocate the vector that we are storing all of our calculations in, R only needs to generate the record of this in its memory once. Then it is essentially filling in the values. In the first example, we are replacing the old version of `x` with the new version, and each time `R` needs to allocate memory to do so.

4. Can you think of code that will be even faster?
```{r}
rm(x)
x <- 1:10000
system.time(x <- x^2)
```
Why is this faster?

This is faster because `R` is vectorized, so we have no need to run a for loop. Instead it does the computation (squaring the values) on the vector itself all simulataneously. Behind the scenes, R is likely sending the computation to some very fast code written in a lower level language (either `C` or `fortran`)

5. So what is the lesson learned from this?

6. Compare the following pieces of code for speed (you can wrap this in `system.time()`)

```{r}
n <- 1000000 # just run this once, each time you change n

rm(x)
system.time(x <- replicate(n = n, expr = rnorm(1, mean = 5, sd = 5)))

```
**VS**

```{r}
rm(x)
x <- rep(NA, n)
system.time(for (i in 1:n) x[i] <- rnorm(1, mean = 5, sd = 5))
```

Repeat each of these 5 times, and write down how long they take. Now repeat this for `n = 100000` iterations. Repeat for `n = 1000000`

Is there a difference in speed? Can you explain why?

The apply like functions are sort of half way between dynamically growing your object, and pre-allocation. As it has not done a pre-allocation, it does not need to dynamically grow things somewhat. However, it does not do so one value at a time. The take home message is that the apply like family of functions are great to use when you have moderate numbers of calculations to do (upto ~100000 or so), but then they get slower relative to the use of a for loop with pre-allocation.

7. Can you think of a faster way to generate the random numbers?

```{r}
rm(x)
system.time(x <- rnorm(n, mean =5 , sd = 5))
```

Again, use the fact that R does its computations in a vectorized fashion to speed everything up!


8. 